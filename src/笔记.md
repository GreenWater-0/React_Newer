## 四、一般组件与路由组件
    1. 写法不同
      一般组件：<Demo />
      路由组件：<Rout path='/demo' component={Demo}>
    2. 存放位置不同
      一般组件：Components
      路由组件：pages
    3. 接收到的props不同
      一般组件：传什么接收什么
      路由组件：
          history:
                go: ƒ go(n)
                goBack: ƒ goBack()
                goForward: ƒ goForward()
                push: ƒ push(path, state)
                replace: ƒ replace(path, state)
          location:
                hash: ""
                pathname: "/home"
                search: ""
                state: undefined
          match:
                isExact: true
                params: {}
                path: "/home"
                url: "/home"
          staticContext: undefined



          
          history:
                action: "POP"
                block: ƒ block(prompt)
                createHref: ƒ createHref(location)
                go: ƒ go(n)
                goBack: ƒ goBack()
                goForward: ƒ goForward()
                length: 3
                listen: ƒ listen(listener)
                // location和下面的一样
                location: {pathname: "/home", search: "", hash: "", state: undefined}
                push: ƒ push(path, state)
                replace: ƒ replace(path, state)
                __proto__: Object
          location:
                hash: ""
                pathname: "/home"
                search: ""
                state: undefined
                __proto__: Object
          match:
                isExact: true
                params: {}
                path: "/home"
                url: "/home"
                __proto__: Object
          staticContext: undefined

## 五、NavLink与封装MyNavLink

## 六、Switch
      单一匹配

## 七、多级路径刷新页面样式丢失

## 八、严格匹配与模糊匹配

## 九、match的params属性，包含传递的参数
      1. params参数
            路由链接，<Link to='/..../id/name/age' />
            注册申明，<Route path='/..../:id/:name/:age' component={} />
            接收参数，const{id, name, age} = this.props.match.params
      2. search参数 // 明文传递
            路由链接，<Link to="/..../?id=''&name=''&age=''" />
            注册申明，无需声明参数，正常注册即可
            备注：获取到的urlencoded编码字符串，需要借助querystring解析
      3. state参数 // 悄悄传递
            路由链接，<Link to={{pathname: '', state: {} }}>{msgObj.title}</Link>
      4. 编程式路由
            // replace 跳转
                  // 携带params参数
                  // 携带search参数
                  // 携带state参数
            this.props.histroy.push('路由')
            // push 跳转
            this.props.histroy.replace('路由')

            借助this.props.histroy对象的API进行跳转、前进、后退
            this.props.go()
            this.props.forward()
            this.props.push()
            this.props.replace()

            withRouter()      // 函数，加工一般组件，让一般组件具备路由组件所特有的API
            接收一个一般组件，给一般组件添加路由组件的属性
## 十、BrowserRouter和HashRouter的区别
      1. 底层原理不一样
            BrowserRouter 使用的是H5的history的API 不兼容IE9及以下版本
            HashRouter 使用的是URL的哈希值
      2. path表现形式不一样
            HashRouter路径包含#
      3. 刷新对state参数的影响
            （1）BrowserRouter没有任何影响，因为state保存在history对象中
            （2）HashRouter刷新后会导致state参数的丢失

## 十一、Redux
      1. 什么时候使用Redux
            1. 某个组件的状态 需要让其他组件可以随时拿到 （共享）
            2. 一个组件需要改变另一个组件的状态（通信）
            3. 总体原则：能不用则不用，如果不用比较吃力才使用